David Parnas’ paper "Designing Software for Ease of Extension and Contraction" the first argument emphasized that a program has to be flexible for future program subsets. Parpas later said that this flexibility comes at the expense of generality. I think that programs should be designed to be flexible over being general for one simple reason: when you make your program, you have no clue what it will be used for in the future. A program has to be able to run even if a couple of its components are changed. Suppose the program is not able to function correctly after an element is changed. In that case, it only increases the time required to get the program fully functional again, further increasing the project’s costs and extending the time until the program is ready for the customer. If the costs and time until completion are not kept in check, it will most likely be canceled.
Parnas’ next argument is that designing a virtual machine program is more efficient than a “flowchart approach.” The virtual machine can remove additional instruction, fill in some missed instructions, and schedule execution of the program to use the machine’s resources as efficiently as possible. I think that this is exceptionally beneficial as a program is developed. Knowing both C and Java really highlights this. In C, the user has to manage the system’s memory themselves, which can lead to a system crash if there is a memory leak. Java, on the other hand, automatically manages a select amount of memory. That is, the user gets to set how much of the system’s memory Java can use, and Java makes the most of it. Java will also get rid of extra memory data using its garbage collector, so it has less unused memory objects. Both C and Java are a buffer between the user and the instructions the systems get to perform. Both are optimized to use specific instructions as efficiently as possible, reducing the strain on the system’s resources. Due to the memory management contained in Java, I think that is why it is more of a “Skyscraper builder” over C and is an example of why a virtual machine is more efficient over an old fashion “flowchart” design.
Parnas’ final argument is one that I have heard before. Throughout my computer science classes, it was stressed to avoid duplication as much as possible. Reducing duplication throughout code can be great at reducing the size required for storing the program; it can be detrimental to its complexity.  Having more subsets, interfaces, and extensions increase the number of components that must work together to accomplish a common goal, which again brings up the importance of Parnas’ first argument that the program must be designed to be flexible. If the program components are designed flexibly, all components of a program should work if one of them is updated, with maybe minor modifications to accommodate new features. If it is not designed properly, then each component will need to be updated, and in the worst-case scenario, completely redone. This scenario is why Parnas’ last argument calling for less duplication should be taken with a grain of salt. If you remove duplication in your code, you need to make it flexible or end up back to square one. Besides that, I agree with reducing duplication as much as possible so that a program requires more thinking of a smart design that is extremely flexible and can be worked on quickly in the future.
