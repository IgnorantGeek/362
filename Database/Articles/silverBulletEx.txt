Frederick Brooke’s paper titled “No Silver Bullet” lists several challenges that software design faces. Complexity was named first, and I do not think that this challenge has been overcome yet, just dulled down a little bit. With object-oriented programming, a program can be read and worked on easier, since each part of the program can be in its own module, allowing for better readability, but not fixing the size issue. Brooke’s next challenge was a problem of conformity. I feel that this has also been dulled down a little more than where it was, with the universal ways of making a 2d array or making a list, for example. In these aspects, we do have a uniform way to make them. However, this conformity has yet to occur at the program level, so I say it has only been dulled down since Brooke released his paper. Changeability I feel has been conquered by modern-day design. The whole goal of design these days is to allow a program to function with minor changes if one module is overhauled, and is why I think software designers have conquered it. Invisibility, Brooke’s last challenge, I feel, has also been conquered. Software designers map out a development path for the project to take in most design forms, which removes the invisible and un-visualizable portion of making a program.
Brooke also listed several hopes for advances in software development, the first being the efficiency of a high-level language. He predicted that these high-level languages would be training programmers to use modern software design techniques. Today, it has done this and more. All beginning programming classes at Iowa State use these higher-level languages to teach students these software-design techniques, but it has evolved past that. As was said in class last week, Java is a language to build skyscrapers, unlike lower languages like C. Brooke also predicted that object-oriented programming would eliminate some of the challenges found in the paragraph above it did to a great extent in complexity. Without abstraction and interfaces, who knows how many extra lines of code would be required to describe each process, no matter how similar they are. Brooke’s prediction on Artificial intelligence, however, I feel ended up being wrong. He said that it is basically an implementation of expression and will only give marginal gains, but a lot of company’s use A.I. for their programs and websites to make it easier on the consumer. While it was not an “Order of Magnitude” gain like what was hoped for, it still helps the consumer more than a series of prompts. Brooke’s next production came in the form of “Expert Systems.” How I interpreted his definition of expert systems is what we now call a virtual machine. He predicted that virtual machines would vastly reduce the difficulties found in programming, and he was right. Look at Java, for example. IT manages memory automatically and efficiently translates the code to machine code. It even has built-in error checking, so the programmer can find exactly where the error is occurring, unlike languages like C. Automatic programming, consequentially, has also turned out to work for our benefit through virtual machines and auto-generated code found in cars. Brooke’s prediction on graphical programming moved beyond his scope of only being used for showing flowcharts on screen. It has moved on to most supercomputers being comprised mainly of graphic cards due to the superior amount of code they can process. Programming verification was fixed with a virtual machine such as Java that shows where an error occurred, again unlike C. Brooke’s prediction on better programming environments also came true. With UI’s such as eclipse and VI code, allowing easier access to the file systems and even helping the programmer fill in obscure functions. Finally, Brooke’s prediction on workstations becoming faster does not mean they will gain the ability to solve these design problems. However, these better systems allowed more complex software to solve these problems since we can have more code running at once.
